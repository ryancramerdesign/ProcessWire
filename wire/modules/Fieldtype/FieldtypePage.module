<?php

/**
 * ProcessWire Page Fieldtype
 *
 * Field that stories references to one or more ProcessWire pages. 
 *
 * For documentation about the fields used in this class, please see:  
 * /wire/core/Fieldtype.php
 * /wire/core/FieldtypeMulti.php
 * 
 * ProcessWire 2.x 
 * Copyright (C) 2010 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class FieldtypePage extends FieldtypeMulti {

	public static function getModuleInfo() {
		return array(
			'title' => 'Page Reference',
			'version' => 100,
			'summary' => 'Field that stores one or more references to ProcessWire pages',
			'permanent' => true, 
			);
	}

	const derefAsPageArray = 0; 
	const derefAsPageOrFalse = 1; 
	const derefAsPageOrNullPage = 2;

	/**
	 * Subfield names that will match to the 'pages' table, rather than custom fields
	 *
	 */
	protected $nativeNames = array(
		'name', 
		'template',
		'templates_id',
		'parent',
		'parent_id',
		'created',
		'modified',
		);


	/**	
	 * Setup a hook to Pages::delete so that we can remove references when pages are deleted
	 *
	 */
	public function init() {
		$pages = $this->getFuel('pages');
		$pages->addHookAfter('delete', $this, 'hookPagesDelete');
	}

	/**
	 * FieldtypePage instances are only compatible with other FieldtypePage derived classes. 
	 *
	 */
	public function ___getCompatibleFieldtypes(Field $field) {
		$fieldtypes = parent::___getCompatibleFieldtypes($field); 
		foreach($fieldtypes as $type) if(!$type instanceof FieldtypePage) $fieldtypes->remove($type); 
		return $fieldtypes; 
	}

	/**
	 * Delete any records that are referencing the page that was deleted
	 *
	 */
	public function hookPagesDelete($event) {
		if(!$event->return) return; // if delete failed, then don't continue
		$page_id = $event->arguments[0]->id; 
		foreach($this->fuel('fields') as $field) {
			if(!$field->type instanceof FieldtypePage) continue; 
			$sql = "DELETE FROM `{$field->table}` WHERE data='$page_id'";
			$this->db->query($sql); 
		}	
	}

	/**
	 * We want FieldtypePage to autoload so that it can monitor page deletes
	 *
	 */
	public function isAutoload() {
		return true; 
	}

	/**
	 * Return an InputfieldPage of the type configured
	 *
	 */
	public function getInputfield(Page $page, Field $field) {
		$inputfield = $this->fuel('modules')->get("InputfieldPage"); 
		$inputfield->class = $this->className();
		return $inputfield; 
	}

        /**
         * Given a raw value (value as stored in DB), return the value as it would appear in a Page object
	 *
         * @param Page $page
         * @param Field $field
         * @param string|int|array $value
         * @return string|int|array|object $value
         *
         */
        public function ___wakeupValue(Page $page, Field $field, $value) {

		$template = null;
		$parent_id = null; 

		if($field->template_id) $template = $this->fuel('templates')->get($field->template_id); 
		if($field->parent_id) $parent_id = $field->parent_id; 

		// handle $value if it's blank, Page, or PageArray
		if($field->derefAsPage > 0) {
			// value will ultimately be a single Page
			if(!$value) return $this->getBlankValue($page, $field); 

			// if it's already a Page, then we're good: return it
			if($value instanceof Page) return $value; 	

			// if it's a PageArray and should be a Page, determine what happens next
			if($value instanceof PageArray) {
				// if there's a Page in there, return the first one
				if(count($value) > 0) return $value->first();

				// it's an empty array, so return whatever our default is
				return $this->getBlankValue($page, $field); 
			}

		} else {
			// value will ultimately be multiple pages

			// if it's already a PageArray, great, just return it
			if($value instanceof PageArray) return $value; 

			// setup our default/blank value 
			$pageArray = $this->getBlankValue($page, $field); 

			// if $value is blank, then return our default/blank value
			if(empty($value)) return $pageArray; 
		}

		// if we made it this far, then we know that the value was not empty
		// so it's going to need to be populated from one type to the target type

		// we're going to be dealing with $value as an array this point forward
		// this is for compatibility with the Pages::getById function
		if(!is_array($value)) $value = array($value); 

		if($field->derefAsPage > 0) {
			// we're going to return a single page, NullPage or false
			$pg = false;
			if(count($value)) {
				// get the first value in a PageArray, using $template and parent for optimization
				$pageArray = $this->fuel('pages')->getById(array((int) reset($value)), $template); 
				if(count($pageArray)) $pg = $pageArray->first();
			}
			if(!$pg || ($pg && $pg->status >= Page::statusUnpublished)) $pg = $this->getBlankValue($page, $field);
			return $pg; 

		} else {
			// we're going to return a PageArray
			$pageArray = $this->fuel('pages')->getById($value, $template); 
			foreach($pageArray as $pg) {
				// remove any pages that have an unpublished status
				if($pg->status >= Page::statusUnpublished) $pageArray->remove($pg); 
			}
			$pageArray->resetTrackChanges(); 
			return $pageArray; 
		}
        }

        /**
         * Given an 'awake' value, as set by wakeupValue, convert the value back to a basic type for storage in DB. 
         *              
         * @param Page $page
         * @param Field $field
         * @param string|int|array|object $value
         * @return string|int
         *
         */
        public function ___sleepValue(Page $page, Field $field, $value) {

		$sleepValue = array();

		if($field->derefAsPage > 0) {
			// if the $value isn't specifically a Page, make it a blank array for storage
			if(!$value instanceof Page || !$value->id) return $sleepValue; 
			// if $value is a Page (not a NullPage) then place it's ID in an array for storage
			$sleepValue[] = $value->id; 
		} else {
			// if $value isn't a PageArray then we'll store a blank array
			if(!$value instanceof PageArray) return $sleepValue; 
			// iterate through the array and place each Page ID
			foreach($value as $pg) {
				if(!$pg->id) continue; 
				$sleepValue[] = $pg->id; 
			}
		}

		return $sleepValue;
        }

	/**
	 * Return either a blank Page or a blank PageArray
	 *
	 */
	public function getBlankValue(Page $page, Field $field) {

		if($field->derefAsPage == FieldtypePage::derefAsPageArray) {
			// multi page blank value
			$pageArray = new PageArray();
			$pageArray->setTrackChanges(true);
			return $pageArray;

		} else if($field->derefAsPage == FieldtypePage::derefAsPageOrFalse) {
			// single page possible blank values
			return false;

		} else if($field->derefAsPage == FieldtypePage::derefAsPageOrNullPage) {
			// single page possible blank values
			return new NullPage(); 
		}

	}

	/**
	 * Given a string value return either a Page or PageArray
	 *	
	 * @param Page $page
	 * @param Field $field
	 * @param string $value
	 * return Page|PageArray
	 *
	 */
	protected function sanitizeValueString(Page $page, Field $field, $value) {

		$selector = '';
		$result = false;

		if(Selectors::stringHasOperator($value)) {
			// selector string
			$selector = $value; 
			$inputfield = $field->getInputfield($page); 
			$selectablePages = $inputfield->getSelectablePages($page); 
			$result = $selectablePages->filter($selector); 

		} else if(ctype_digit("$value")) {
			// page ID
			$result = $this->pages->get("id=" . $value); 
		
		} else if(strpos($value, '|') !== false && ctype_digit(str_replace('|', '', $value))) {
			$result = $this->pages->getById(explode('|', $value)); 

		} else if(strpos($value, '|') !== false && ctype_digit(str_replace('|', '', $value))) {
			// CSV string separated by '|' characters
			$result = $this->pages->getById(explode('|', $value)); 	

		} else if(strlen($value) && $value[0] == '/') {
			// path to page
			$result = $this->pages->get($value); 
		}

		return $result; 
	}

	/**
	 * Given a value of unknown type, return a Page or PageArray (depending on $field->derefAsPage setting)
	 *
	 * @param Page $page
	 * @param Field $field
	 * @param Page|PageArray|string|int $value
	 * @return Page|PageArray|bool Returns false if value can't be converted to the proper object type.
	 *
	 */
	public function sanitizeValue(Page $page, Field $field, $value) {
		if($field->derefAsPage > 0) return $this->sanitizeValuePage($page, $field, $value); 
		return $this->sanitizeValuePageArray($page, $field, $value); 
	}

	/**
	 * Handles the sanitization of values when target is a single Page
	 *
	 */
	protected function sanitizeValuePage(Page $page, Field $field, $value) {

		if(!$value) return $this->getBlankValue($page, $field); 
		if($value instanceof Page) return $value;
		if($value instanceof PageArray) $value = $value->first();
		if(is_string($value) || is_int($value)) {
			$value = $this->sanitizeValueString($page, $field, $value); 
			if($value instanceof PageArray) $value = $value->first();
		}
		return (($value instanceof Page) && $value->id) ? $value : $this->getBlankValue($page, $field); 
	}

	/**
	 * Handles the sanitization of values when target is a PageArray
	 *
	 */
	protected function sanitizeValuePageArray(Page $page, Field $field, $value) {

		// if they are setting it to a PageArray, then we'll take it
		if($value instanceof PageArray) return $value; 

		// otherwise, lets get the current value so we can add to it or return it
		$pageArray = $page->get($field->name); 

		// if no value was provided, then return the existing value already in the page
		if(!$value) return $pageArray; 

		// if it's a string, see if we can convert it to a Page or PageArray
		if(is_string($value)) $value = $this->sanitizeValueString($page, $field, $value); 

		// if it's a Page, and not  NullPage, add it to the existing PageArray
		if($value instanceof Page) {
			if($value->id) return $pageArray->add($value); 
				else return $pageArray;
		}

		// if it's a new PageArray, combine it with the existing PageArray
		if($value instanceof PageArray) {
			foreach($value as $pg) {
				if(!$pg->id) continue; 
				$pageArray->add($pg); 
			}
			return $pageArray; 
		}

		if(!is_array($value)) $value = array($value); 
		foreach($value as $pg) $pageArray->add($pg); 

		return $pageArray; 
	}

	/**
	 * Update a DatabaseSelectQuery object to match a Page
	 *
	 * @param DatabaseSelectQuery $query
	 * @param string $table
	 * @param string $subfield
	 * @param string $operator
	 * @param string $value
	 * @return DatabaseSelectQuery
	 *
	 */
	public function getMatchQuery($query, $table, $subfield, $operator, $value) {

		$names = array(
			'id',
			'data',
			'pages_id',
			'path',
			'url',
			'sort',
			);


		// if subfield is 'data' (meaning no subfield specified) and it's in the format of 'some-string', 
		// then we assume this to be a page name
		if($subfield == 'data' && !ctype_digit("$value") && strlen($value) && strpos($value, '/') === false) {
			$subfield = 'name';
		}

		// let the FieldtypeMulti base class handle count queries
		if($subfield == 'count') {
			return parent::getMatchQuery($query, $table, $subfield, $operator, $value);

		} else if(in_array($subfield, $names)) { 

			if(!$this->fuel('db')->isOperator($operator)) throw new WireException("Operator '$operator' is not implemented in {$this->classname}"); 
			
			if(in_array($subfield, array('id', 'path', 'url'))) $subfield = 'data'; 

			// if a page path rather than page ID was provided, then we translate the path to an ID for API syntax convenience
			if(!ctype_digit("$value")) {
				if(substr(trim($value), 0, 1) == '/') {
					// path from root
					$v = $this->pages->get($value); 
					if($v && $v->id) $value = $v->id; 
				}
			}

			$value = $this->fuel('db')->escape_string($value); 

			if($operator == '!=') {
				$t = $query->field->getTable();
				$query->where("(SELECT COUNT(*) FROM $t WHERE $t.pages_id=pages.id AND $t.$subfield='$value')=0"); 
			} else {
				$query->where("($table.{$subfield}{$operator}'$value')"); // pages.id AND $table.pages_id{$operator}'$value')");
			}

		} else if($this->getMatchQueryNative($query, $table, $subfield, $operator, $value)) {
			// great

		} else if($this->getMatchQueryCustom($query, $table, $subfield, $operator, $value)) {
			// wonderful as well

		} else {
			// we were unable to determine what subfield is
			throw new WireException("Unknown subfield: $subfield"); 
		}

		return $query; 
	}

	/**
	 * Update a DatabaseSelectQuery object to match a Page with a subfield native to pages table
	 *
	 * @param DatabaseSelectQuery $query
	 * @param string $table
	 * @param string $subfield
	 * @param string $operator
	 * @param string $value
	 * @return bool True if used, false if not
	 *
	 */
	protected function getMatchQueryNative($query, $table, $subfield, $operator, $value) {


		if(!in_array($subfield, $this->nativeNames)) return false; 

		// we let the custom field query matcher handle the '!=' scenario
		if($operator == '!=') return $this->getMatchQueryCustom($query, $table, $subfield, $operator, $value); 

		if($subfield == 'created' || $subfield == 'modified') {
			if(!ctype_digit($value)) $value = strtotime($value); 
			$value = (int) $value; 

		} else if(in_array($subfield, array('template', 'templates_id'))) {
			$template = $this->templates->get($subfield); 
			$value = $template ? $template->id : 0; 
			$subfield = 'templates_id';
			
		} else if(in_array($subfield, array('parent', 'parent_id'))) {
			if(!ctype_digit("$value")) $value = $this->pages->get($value)->id; 
			$subfield = 'parent_id';	
		
		} else if($subfield == 'name') {
			$value = $this->sanitizer->pageName($value); 

		} else $value = (int) $value; 

		static $n = 0;
		$table2 = "_fieldtypepage" . (++$n);
		$value = $this->fuel('db')->escape_string($value); 

		$query->join("pages AS $table2 ON $table2.$subfield$operator'$value'"); 
		$query->where("($table.data=$table2.id)"); 

		return true; 
	}

	/**
	 * Update a DatabaseSelectQuery object to match a Page containing a matching custom subfield
	 *
	 * @param DatabaseSelectQuery $query
	 * @param string $table
	 * @param string $subfield
	 * @param string $operator
	 * @param string $value
	 * @return bool true if used, false if not
	 *
	 */
	protected function getMatchQueryCustom($query, $table, $subfield, $operator, $value) {

		if(in_array($subfield, $this->nativeNames)) {
			// fine then, we can handle that here when needed (like !=)
		} else {
			$subfield = wire('fields')->get($subfield);
			if(!$subfield) return false; // not a custom field
			$subfield = $subfield->name; 
		}

		$field = $query->field; 

		// perform a separate find() operation for the subfield
		$pageFinder = new PageFinder();
		$value = wire('sanitizer')->selectorValue($value);

		// build a selector to find matching pagerefs 
		// @todo should $selector include check_access=0 or even include=all?
		$selector = 'include=hidden, ';
		if($field->findPagesSelector) $selector .= $field->findPagesSelector . ", ";
		if($field->parent_id) $selector .= "parent_id={$field->parent_id}, ";
		if($field->template_id) $selector .= "templates_id={$field->template_id}, ";
		// @todo note $field->findPagesCode is not implemented

		if($operator == '!=') {

			$selector .= "{$subfield}=$value, ";
			$matches = $pageFinder->find(new Selectors(trim($selector, ', ')));
			if(count($matches)) { 
				$ids = array();
				foreach($matches as $match) $ids[$match['id']] = $match['id'];
				static $xcnt = 0; 
				$t = 'x_' . $field->table . (++$xcnt);
				$query->leftjoin("{$field->table} AS $t ON $t.pages_id=pages.id AND $t.data IN(" . implode(',', $ids) . ")"); 
				$query->parentQuery->where("$t.data IS NULL"); 
			}

		} else {

			$selector .= "{$subfield}$operator$value, ";
			$matches = $pageFinder->find(new Selectors(trim($selector, ', ')));

			// use the IDs found from the separate find() as our getMatchQuery
			if(count($matches)) {
				$ids = array();
				foreach($matches as $match) $ids[$match['id']] = $match['id'];
				$query->where("$table.data IN(" . implode(',', $ids) . ")");
			} else $query->where("1>2"); // forced non-match

		}

		return true;
	}

	/**
	 * Return the database schema in predefined format 
	 *
	 */
	public function getDatabaseSchema(Field $field) {
		$schema = parent::getDatabaseSchema($field); 
		$schema['data'] = 'int NOT NULL';
		$schema['keys']['data'] = 'KEY data (data, pages_id, sort)'; 
		return $schema;
	}

	/**
	 * Return configuration fields definable for each FieldtypePage
	 *
	 */
	public function ___getConfigInputfields(Field $field) {

		$inputfields = parent::___getConfigInputfields($field);
		
		$select = $this->modules->get("InputfieldRadios"); 
		$select->attr('name', 'derefAsPage'); 
		$select->label = $this->_('Dereference in API as');
		$select->description = $this->_('If your field will contain multiple pages, then you should select the first option (PageArray). If your field only needs to contain a single page, then select one of the single Page options (if you are not sure which, select the last option).'); // Long description for: dereference in API
		$select->addOption(FieldtypePage::derefAsPageArray, $this->_('Multiple pages (PageArray)')); 
		$select->addOption(FieldtypePage::derefAsPageOrFalse, $this->_('Single page (Page) or boolean false when none selected')); 
		$select->addOption(FieldtypePage::derefAsPageOrNullPage, $this->_('Single page (Page) or empty page (NullPage) when none selected')); 

		$select->attr('value', (int) $field->derefAsPage);  
		$inputfields->append($select);
		return $inputfields; 
	}
}

