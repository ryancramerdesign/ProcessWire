<?php

/**
 * ProcessWire Page Paths
 *
 * Keeps a cache of page paths to improve performance and 
 * make paths more queryable by selectors.
 *
 * 
 * ProcessWire 2.x 
 * Copyright (C) 2013 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 * 
 *
 */

class PagePaths extends WireData implements Module {

	public static function getModuleInfo() {
		return array(
			'title' => 'Page Paths', 
			'version' => 1, 
			'summary' => "Enables page paths/urls to be queryable by selectors. Also offers potential for improved load performance. Builds an index at install (may take time on a large site). Beta Test.",
			'singular' => true, 
			'autoload' => true, 
			);
	}

	/**
	 * Table created by this module
	 *
	 */
	const dbTableName = 'pages_paths';

	/**
	 * Initialize the hooks
	 *
	 */
	public function init() {
		$this->pages->addHook('moved', $this, 'hookPageMoved'); 
		$this->pages->addHook('renamed', $this, 'hookPageMoved'); 
		$this->pages->addHook('added', $this, 'hookPageMoved'); 
		$this->pages->addHook('deleted', $this, 'hookPageDeleted');
	}

	/**
	 * Hook called when a page is moved or renamed
	 *
	 */
	public function hookPageMoved(HookEvent $event) {
		$page = $event->arguments[0];
		$this->updatePagePath($page->id, $page->path); 
	}


	/**
	 * When a page is deleted
	 *
	 */
	public function hookPageDeleted(HookEvent $event) {
		$page = $event->arguments[0];
		$this->db->query("DELETE FROM " . self::dbTableName . " WHERE pages_id=" . ((int) $page->id)); 
	}

	/**
	 * Given a page ID, return the page path or NULL if not found.
	 *
	 * @param int $id
	 * @return string|null
	 *
	 */
	public function getPath($id) {
		$table = self::dbTableName;
		$id = (int) $id; 
		$result = $this->db->query("SELECT path FROM $table WHERE pages_id=$id"); 
		if(!$result->num_rows) return null;
		list($path) = $result->fetch_row(); 
		$path = strlen($path) ? "/$path/" : "/";
		return $path;
	}

	/**
	 * Given a page path, return the page ID or NULL if not found.
	 *
	 * @param string $path
	 * @return int|null
	 *
	 */
	public function getID($path) {
		$table = self::dbTableName;
		$path = $this->db->escape_string(trim($path, '/'));
		$result = $this->db->query("SELECT pages_id FROM $table WHERE path='$path'"); 
		if(!$result->num_rows) return null;
		list($id) = $result->fetch_row(); 
		return (int) $id;
	}

	/**
	 * Perform a path match for use by PageFinder
	 *
	 * @param DatabaseQuerySelect $query
	 * @param Selector $selector
	 *
	 */
	public function getMatchQuery(DatabaseQuerySelect $query, Selector $selector) {

		static $n = 0;
		$n++;
		$table = self::dbTableName;
		$alias = "$table$n";
		$value = $selector->value;
		$joinType = $selector->not ? 'leftjoin' : 'join';

		$query->join("$table AS $alias ON pages.id=$alias.pages_id"); 

		if(in_array($selector->operator, array('=', '!=', '<>', '>', '<', '>=', '<='))) {
			if(!is_array($value)) $value = array($value);
			$where = '';
			foreach($value as $path) {
				if($where) $where .= $selector->not ? " AND " : " OR ";
				$path = $this->db->escape_string(trim($path, '/')); 
				$where .= ($selector->not ? "NOT " : "") . "$alias.path{$selector->operator}'$path'";
			}
			$query->where("($where)");

		} else {
			if(is_array($value)) {
				$error = "Multi value using '|' is not supported with path/url and '$selector->operator' operator";
				throw new PageFinderSyntaxException($error);
			}
			if($selector->not) {
				$error = "NOT mode isn't yet supported with path/url and '$selector->operator' operator";
				throw new PageFinderSyntaxException($error);
			}
			$ft = new DatabaseQuerySelectFulltext($query);
			$ft->match($alias, 'path', $selector->operator, trim($value, '/'));
		}
	}

	/**
	 * Updates path for $page and all children
	 *
	 * @param int $id 
	 * @param string $path
	 * @param bool $hasChildren Omit if true or unknown
	 * @param int $level Recursion level, you should omit this param
	 * @return int Number of paths updated
	 *
	 */
	protected function updatePagePath($id, $path, $hasChildren = true, $level = 0) {

		$table = self::dbTableName;
		$id = (int) $id;
		$db = $this->db;
		$path = trim($path, '/');
		$_path = $db->escape_string($path);
		$numUpdated = 1;

		$sql = 	"INSERT INTO $table (pages_id, path) VALUES($id, '$_path') " . 
			"ON DUPLICATE KEY UPDATE pages_id=VALUES(pages_id), path=VALUES(path)"; 

		$db->query($sql);

		if($hasChildren) {

			$sql = 	"SELECT pages.id, pages.name, COUNT(children.id) FROM pages " . 
				"LEFT JOIN pages AS children ON children.id=pages.parent_id " . 
				"WHERE pages.parent_id=$id " . 
				"GROUP BY pages.id ";

			$result = $db->query($sql);

			while($row = $result->fetch_row()) {
				list($id, $name, $numChildren) = $row; 
				$numUpdated += $this->updatePagePath($id, "$path/$name", $numChildren > 0, $level+1); 
			}
		}

		if(!$level) $this->message(sprintf($this->_n('Updated %d path', 'Updated %d paths', $numUpdated), $numUpdated)); 

		return $numUpdated;
	}

	/**
	 * Install the module
	 *
	 */
	public function ___install() {
		
		$table = self::dbTableName;

		$this->db->query("DROP TABLE IF EXISTS $table"); 

		$sql = 	"CREATE TABLE $table (" . 
			"pages_id int(10) unsigned NOT NULL, " . 
			"path text CHARACTER SET ascii COLLATE ascii_general_ci NOT NULL, " . 
			"PRIMARY KEY pages_id (pages_id), " .
			"UNIQUE KEY path (path(500)), " . 
			"FULLTEXT KEY path_fulltext (path)" . 
			") ENGINE=MyISAM";

		$this->db->query($sql); 
		$numUpdated = $this->updatePagePath(1, '/'); 
	}

	/**
	 * Uninstall the module
	 *
	 */
	public function ___uninstall() {
		$this->db->query("DROP TABLE " . self::dbTableName); 
	}

}
